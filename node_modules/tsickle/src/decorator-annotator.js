/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/decorator-annotator", ["require", "exports", "tsickle/src/decorators", "tsickle/src/rewriter", "tsickle/src/type-translator", "tsickle/src/typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var decorators_1 = require("tsickle/src/decorators");
    var rewriter_1 = require("tsickle/src/rewriter");
    var type_translator_1 = require("tsickle/src/type-translator");
    var ts = require("tsickle/src/typescript");
    function shouldLower(decorator, typeChecker) {
        try {
            for (var _a = __values(decorators_1.getDecoratorDeclarations(decorator, typeChecker)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var d = _b.value;
                // TODO(lucassloan):
                // Switch to the TS JSDoc parser in the future to avoid false positives here.
                // For example using '@Annotation' in a true comment.
                // However, a new TS API would be needed, track at
                // https://github.com/Microsoft/TypeScript/issues/7393.
                var commentNode = d;
                // Not handling PropertyAccess expressions here, because they are
                // filtered earlier.
                if (commentNode.kind === ts.SyntaxKind.VariableDeclaration) {
                    if (!commentNode.parent)
                        continue;
                    commentNode = commentNode.parent;
                }
                // Go up one more level to VariableDeclarationStatement, where usually
                // the comment lives. If the declaration has an 'export', the
                // VDList.getFullText will not contain the comment.
                if (commentNode.kind === ts.SyntaxKind.VariableDeclarationList) {
                    if (!commentNode.parent)
                        continue;
                    commentNode = commentNode.parent;
                }
                var range = ts.getLeadingCommentRanges(commentNode.getFullText(), 0);
                if (!range)
                    continue;
                try {
                    for (var range_1 = __values(range), range_1_1 = range_1.next(); !range_1_1.done; range_1_1 = range_1.next()) {
                        var _c = range_1_1.value, pos = _c.pos, end = _c.end;
                        var jsDocText = commentNode.getFullText().substring(pos, end);
                        if (jsDocText.includes('@Annotation'))
                            return true;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (range_1_1 && !range_1_1.done && (_d = range_1.return)) _d.call(range_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
        var e_2, _e, e_1, _d;
    }
    exports.shouldLower = shouldLower;
    // DecoratorClassVisitor rewrites a single "class Foo {...}" declaration.
    // It's its own object because we collect decorators on the class and the ctor
    // separately for each class we encounter.
    var DecoratorClassVisitor = /** @class */ (function () {
        function DecoratorClassVisitor(typeChecker, rewriter, classDecl, importedNames) {
            this.typeChecker = typeChecker;
            this.rewriter = rewriter;
            this.classDecl = classDecl;
            this.importedNames = importedNames;
            if (classDecl.decorators) {
                var toLower = this.decoratorsToLower(classDecl);
                if (toLower.length > 0)
                    this.decorators = toLower;
            }
        }
        /**
         * Determines whether the given decorator should be re-written as an annotation.
         */
        DecoratorClassVisitor.prototype.decoratorsToLower = function (n) {
            var _this = this;
            if (n.decorators) {
                return n.decorators.filter(function (d) { return shouldLower(d, _this.typeChecker); });
            }
            return [];
        };
        /**
         * gatherConstructor grabs the parameter list and decorators off the class
         * constructor, and emits nothing.
         */
        DecoratorClassVisitor.prototype.gatherConstructor = function (ctor) {
            var ctorParameters = [];
            var 